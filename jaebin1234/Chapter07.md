# 7장. 분산 시스템을 위한 유일 ID 생성기 설계

---

## 1. 왜 분산 ID 생성기가 필요한가?

* 단일 서버/단일 DB라면 `AUTO_INCREMENT`, `SEQUENCE`로 충분하다.
* 하지만 분산 환경에서는 다음 문제가 생긴다.

1. 단일 DB `AUTO_INCREMENT`만 쓰는 경우

* 모든 쓰기가 한 DB에 몰려 병목 발생
* DB가 죽으면 ID 발급도 같이 멈춤(SPOF)
* 여러 데이터센터/리전에서 공용으로 쓰기 어려움

2. 여러 DB에 각각 `AUTO_INCREMENT`를 쓰는 경우

* DB마다 같은 값이 생성될 수 있어 “전역 유일” ID가 깨진다.
* 샤드마다 offset/step을 달리하는 방법(예: 1,3,5… / 2,4,6…)도 있지만

  * 샤드 수가 바뀌면 관리가 매우 힘들다.
  * 시간 순 정렬도 깨지기 쉽다.

그래서 “분산 환경에서 전역 유일 + 시간순 정렬 + 고성능”을 만족하는 ID 생성기를 별도로 설계하는 것이 목표다.

---

## 2. 문제 이해 및 요구사항

설계해야 할 ID의 요구사항을 정리하면:

* ID는 전역에서 유일해야 한다.
* ID는 숫자로만 구성되어야 한다. (DB 인덱스, 정렬 등에 유리)
* ID는 64비트 정수 범위 안에 들어야 한다.
* ID는 발급 시각 기준으로 정렬 가능해야 한다.
* 초당 10,000개 이상의 ID를 생성할 수 있어야 한다.
  (실제 Snowflake 스타일이면 그 이상도 충분히 가능)

---

## 3. 유일 ID 생성 전략 비교

### 3.1 다중 마스터 복제 기반 시퀀스

* 아이디어

  * k개의 DB 서버가 있고, 각 서버는 자신의 시퀀스를 가진다.
  * 예: 서버 수 k=2인 경우

    * 서버1: 1, 3, 5, 7, …
    * 서버2: 2, 4, 6, 8, …
  * “이전 ID + 서버 수” 방식으로 다음 ID 생성.

* 장점

  * 각 DB가 따로 ID를 생성하므로 어느 정도 분산 가능.

* 단점

  * 여러 데이터센터/리전에 걸쳐 확대하면 설계 복잡.
  * ID 값이 “시간 순”과 직접적으로 매핑되지 않는다.
  * 서버 수가 바뀌면(step이 달라져서) 설계가 꼬인다.
  * 서버 추가/삭제 시에도 시퀀스 규칙 유지가 어렵다.

→ 초창기에는 쓸 수 있지만, 대규모 분산/동적 확장에는 부적합.

---

### 3.2 UUID

* UUID란?

  * 컴퓨터 시스템 내에서 객체를 유일하게 식별하기 위한 128비트 값.
  * v1, v4 등 여러 버전이 있다.

* 장점

  * 각 서버가 독립적으로 생성 가능 (서버 간 조율 필요 없음)
  * 전역 유일성에 매우 강하다.
  * 규모 확장에 매우 유리: “ID 중앙 서버”가 필요 없다.

* 단점

  * 128비트라 길다. (저장 공간, 인덱스 비용 증가)
  * 일반 UUID(v4)는 시간 순 정렬이 어렵다.
  * 문자열 형태(하이픈 포함)로 쓰는 경우 숫자-only 요구사항을 만족하지 못한다.

→ “간편한 전역 유일 ID”에는 좋지만,
“64비트 숫자 + 시간순 정렬” 요구사항에는 맞지 않는다.

---

### 3.3 티켓 서버 (Ticket Server)

* 개념

  * 중앙 집중형 ID 생성기 서버.
  * 예: `/next_id` API를 두고, 각 서비스가 필요할 때 호출해서 시퀀스 번호를 받는 방식.

* 장점

  * 유일 ID, 숫자 ID 생성이 매우 쉽다.
  * 구현이 간단해서 중소 규모 서비스에는 충분히 실용적.

* 단점

  * 티켓 서버 자체가 SPOF가 된다.
  * 고가용성을 위해서 티켓 서버를 이중화/복제하면

    * 다시 동기화, 락, 복제 이슈가 생긴다.
  * 트래픽이 커질수록 티켓 서버가 병목이 될 수 있다.

→ 소규모/단일 리전이면 괜찮지만, 대규모 분산 시스템에는 한계가 있다.

---

### 3.4 트위터 스노플레이크(Snowflake) 스타일

결국 가장 많이 회자되는 해법이 Snowflake 스타일 ID 구조다.

* 64비트 ID를 다음 구성을 가진 비트 필드로 나눈다.

예시:

* 1비트: 사인비트(항상 0)
* 41비트: 타임스탬프 (특정 기준 시각 이후의 경과 밀리초)
* 5비트: 데이터센터 ID
* 5비트: 서버(노드) ID
* 12비트: 일련번호(같은 밀리초 내에서 증가하는 시퀀스)

합계: 1 + 41 + 5 + 5 + 12 = 64비트

특징 요약:

* 타임스탬프가 상위 비트 → 전체 ID는 시간순으로 정렬 가능.
* 데이터센터/서버 ID 조합으로 전 세계 수천~수만 노드까지 확장 가능.
* 한 서버가 1ms 동안 생성할 수 있는 최대 ID 수 = 2¹² = 4096개
  → 초당 4096 × 1000 = 4,096,000개까지 가능 (요구사항 10,000개/s는 여유롭게 만족).

---

## 4. 상세 설계

### 4.1 타임스탬프 필드

* 41비트로 표현 가능한 밀리초 수:

  * 약 2⁴¹ ms ≈ 69년 정도.
* 따라서 “기준 시각(epoch)”를 하나 정하고,

  * ID에 저장하는 타임스탬프 = (현재시각 - epoch)의 밀리초 값.
* 형식

  * 내부적으로는 UTC 기준 밀리초 단위로 처리.

예:

* 트위터 기원 시각(임의의 날짜)을 epoch로 설정.
* 41비트 타임스탬프 = 현재 UTC ms - epoch ms.

---

### 4.2 데이터센터 ID, 서버 ID

* 5비트 → 0 ~ 31
* 데이터센터 ID 5비트, 서버 ID 5비트를 사용하면:

  * 32개 데이터센터 × 각 데이터센터당 32개 서버 = 최대 1024 노드.

실제 시스템에서는:

* 비트 수를 조정해서

  * 데이터센터를 더 많이, 서버를 더 적게
  * 혹은 그 반대로 설계할 수 있다.

---

### 4.3 일련번호(시퀀스) 필드

* 12비트 → 0 ~ 4095

* 동작 방식

  * 같은 서버에서 같은 밀리초 안에 ID를 생성할 때마다 sequence를 +1.
  * 새 밀리초로 넘어가면 sequence를 0으로 리셋.

* 초당 생성 가능한 ID 수

  * 1ms당 최대 4096개 → 1초(1000ms)당 최대 4,096,000개.

* 시퀀스가 꽉 찼을 때

  * 같은 ms 안에서 sequence > 4095가 되면,
  * 다음 밀리초가 될 때까지 대기(바쁜 대기 or sleep) 후 새 타임스탬프로 ID를 만든다.

---

## 5. 시계 동기화와 NTP

### 5.1 시계 동기화 문제

* 각 서버의 시스템 시간이 다르면,

  * 예: 서버 시간이 “뒤로 되감김(backward)” 되는 상황 →
  * 타임스탬프가 갑자기 줄어들면서 “예전에 발급한 ID보다 작은 값”이 나올 수 있다.
  * 심하면 같은 타임스탬프 + sequence 조합이 나오며 중복 위험.

* 해결 전략(일반적인 패턴)

  1. “현재 시각 < 마지막으로 사용한 시각” 이 감지되면

     * 그 차이만큼 기다렸다가(또는 일정 시간 대기 후) 다시 시도.
  2. 일정 시간 이상 뒤로 가면

     * 에러로 간주하고 알람/운영 개입.
  3. 또는, 타임스탬프 대신 “논리 시계”를 사용하거나,

     * clock skew를 보정하는 offset 값을 유지.

### 5.2 NTP란?

* Network Time Protocol

  * 서버의 시스템 시간을 외부 시간 서버와 동기화하기 위한 프로토콜.
  * 주기적으로 신뢰할 수 있는 NTP 서버에 접속하여 시계 오차를 보정한다.
* Snowflake 스타일 ID 시스템에서도

  * 모든 노드의 시간이 크게 어긋나지 않도록
  * NTP나 내부 시간 동기화 시스템을 활용하는 것이 중요하다.

---

## 6. 요구사항 변화에 따른 비트 조정

* 동시성이 낮고, 시스템 수명이 길어야 하는 애플리케이션이라면:

  * sequence(일련번호) 비트 수를 줄이고
  * 타임스탬프 비트 수를 늘려서, 69년보다 더 긴 수명을 갖게 설계할 수 있다.

예:

* 타임스탬프 42비트, 시퀀스 11비트 등으로 조정.

반대로, 매우 높은 TPS가 필요한 경우:

* 타임스탬프를 “ms” 대신 “1/10 ms” 단위로 줄이거나,
* sequence 비트를 더 늘리는 식으로 설계할 수도 있다.
  (그만큼 전체 수명은 줄어든다.)

---

## 7. 마무리 정리

* 분산 환경에서의 ID 생성은 단순 `AUTO_INCREMENT`로 해결하기 어렵다.

* 대표적인 대안

  * 다중 마스터 시퀀스: 설계·운영 복잡, 확장성 제한.
  * UUID: 전역 유일성과 확장성은 좋지만, 길고 정렬성이 떨어진다.
  * 티켓 서버: 간단하지만 SPOF 및 병목.
  * Snowflake 스타일: 64비트 숫자 + 시간 정렬 + 전역 유일 + 고성능을 동시에 만족.

* Snowflake 스타일의 핵심

  * [타임스탬프 + 데이터센터 ID + 서버 ID + 시퀀스]를 비트 필드로 조합.
  * 전역 유일, 시간순 정렬, 초당 수백만 ID까지 확장 가능.
  * 단, 서버 시계 동기화(NTP, clock skew handling)와 sequence overflow 처리 로직이 중요하다.

