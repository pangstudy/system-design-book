# 8장. URL 단축기 설계 (URL Shortener)

---

## 1. 문제 이해 및 설계 범위 확정

URL 단축기는 크게 두 가지 기능이 있다.

1. URL 단축

   * 긴 URL(long URL)을 짧은 URL(short URL)로 매핑
2. URL 리디렉션

   * 사용자가 단축 URL로 요청 → 원래 긴 URL로 리다이렉트

요구사항 정리:

* 높은 가용성, 장애 감내, 수평 확장 가능해야 한다.
* 트래픽 추정

  * 단축 URL 생성: 하루 1억 개

    * 초당 쓰기: 1억 / (24×3600) ≒ 1,160 req/s
  * 읽기: 쓰기 대비 약 10배로 잡으면

    * 초당 읽기: 11,600 req/s
  * 10년 운영 시 레코드 수

    * 1억 × 365 × 10 ≒ 3,650억 개
  * 원본 URL 평균 길이 100 바이트라고 하면

    * 데이터 크기 ≒ 3,650억 × 100B ≒ 수십 TB 단위

---

## 2. 개략적 설계안

### 2.1 API 엔드포인트 설계

1. URL 단축용

* 예: `POST /api/v1/urls/shorten`

  * 요청 바디: `{"longUrl": "https://very-long-url..."}`
  * 응답: `{"shortUrl": "https://sho.rt/Ab3xYz1"}`

2. URL 리디렉션용

* 예: `GET /{shortKey}`

  * 예: `GET /Ab3xYz1`
  * 응답: 301 또는 302 + Location 헤더(원본 URL)

### 2.2 URL 리디렉션 - 301 vs 302

* 301 Moved Permanently

  * 이 단축 URL은 앞으로 계속 같은 원본 URL로만 리디렉션된다는 의미
  * 브라우저/중간 캐시가 응답을 저장하고, 다음부터는 서버까지 가지 않고 바로 원본 URL로 요청 보낼 수 있음
  * 장점: 서버 부하 감소
  * 단점: 나중에 원본 URL을 바꾸고 싶어도, 이미 캐시된 클라이언트는 변경 반영이 느리거나 안 될 수 있음

* 302 Found (또는 307/308 등)

  * 지금은 이 URL로 보내지만, 다음에 또 물어보면 그때 다시 서버가 알려줘야 한다는 의미
  * 장점: 모든 요청이 서버를 거치므로 트래픽 분석, A/B 테스트, 원본 URL 변경 등에 유리
  * 단점: 301보다 서버 부하 증가

보통 “통계/로그가 중요하면 302”, “그냥 단축만 하면 된다면 301” 같은 식으로 선택한다.

---

## 3. URL 단축 방식 개요

질문 포인트: 긴 URL을 어떻게 짧은 문자열로 매핑할까?

대표적인 접근 두 가지:

1. 해시 함수 사용
2. 정수 ID + Base62 인코딩

해시를 쓸 때 요구사항처럼 “해시로 원본을 복원”하는 것은 일반적인 해시와 개념이 다르고 어렵기 때문에,
실무에서는 대부분 “DB에 longUrl을 저장하고, shortKey만 키로 쓰는 방식”을 쓴다.

---

## 4. 데이터 모델

가장 단순한 RDBMS 모델:

* id: 정수 PK (auto increment 또는 분산 ID)
* short_key: 단축 URL의 키 (예: “Ab3xYz1”)
* long_url: 원본 URL 문자열

인덱스:

* PK(id)
* unique(short_key)
* 필요하다면 long_url에도 인덱스(이미 등록된 URL인지 빠르게 찾기 용도)

NoSQL을 쓸 수도 있지만, 책 스타일 그대로라면 위와 같은 RDB 테이블 구조를 기본으로 잡으면 된다.

---

## 5. 해시 함수와 키 길이

### 5.1 키 공간 크기 계산

* 사용할 문자: 0–9, a–z, A–Z = 62개
* 길이 n인 문자열이 표현할 수 있는 조합 수 = 62ⁿ
* 필요 레코드 수: 약 3,650억 ≒ 3.65 × 10¹¹

62⁷ ≒ 3.5 × 10¹² 수준이라서
길이 7이면 여유 있게 커버 가능하다.

→ shortKey 길이를 7자로 설계하면 충분.

### 5.2 해시 기반 접근

* 긴 URL에 CRC32, MD5, SHA-1 같은 해시 함수 적용
* 결과는 매우 긴 이진 값이므로

  * 앞부분 몇 바이트만 잘라서
  * Base62로 다시 변환 → 길이 7짜리 문자열 만든다.
* 문제: 해시 충돌

해시 충돌 처리 흐름(예시):

1. longUrl을 해싱 → shortKey 후보 생성
2. DB에서 shortKey 조회

   * 없으면 이 키로 저장
   * 있으면 longUrl이 같은지 비교

     * 같다면 이미 생성된 단축 URL이므로 재사용
     * 다르면 충돌
3. 충돌이면

   * 해시 seed를 바꾸거나, longUrl + random salt를 다시 해싱해서 다른 shortKey 생성
   * 또는 shortKey 뒤에 한 글자를 추가하는 등 대응

장점:

* 분산 환경에서 longUrl만 있어도 동일한 shortKey를 계산할 수 있어,
  특정 상황에서 id 기반보다 덜 DB 의존적일 수 있다.

단점:

* 충돌 관리가 귀찮다.
* 해시 잘라 쓰면 충돌 확률이 커지고, 충돌 처리를 위한 추가 로직이 필요하다.

---

## 6. Base62 + ID 기반 접근

실무에서 가장 많이 쓰는 패턴.

1. 새로운 URL이 들어오면 DB에 한 줄 삽입한다.

   * id: auto increment 또는 분산 ID 생성기(Snowflake 등)
   * long_url: 원본
2. 얻어진 id를 62진법(Base62)으로 변환한다.

   * 예: id 125 → “cb” 같은 식으로 인코딩
3. 이 Base62 결과를 shortKey로 사용한다.

Base62 변환 개념:

* 10진수 정수 n에 대해

  * n을 62로 나눈 나머지를 구함 → 0~61에 해당하는 문자 하나
  * 몫으로 다시 62로 나누는 과정을 반복
  * 역순으로 이어 붙이면 Base62 문자열이 된다.

예:

* 0 → “0”
* 61 → “Z”
* 62 → “10”
* …

장점:

* 충돌이 없다. (id가 유일하니까)
* 구현이 매우 단순하다.
* 시간순으로 증가하는 id → Base62 결과도 대체로 길이가 조금씩 증가하는 방식이라 관리가 쉽다.

단점:

* 반드시 중앙의 “id 생성” 지점이 필요하다.

  * 단일 DB auto_increment 사용 시 병목/단일 장애점이 될 수 있음
  * 분산 ID 생성기(Snowflake 방식)를 조합해야 대규모 분산에 대응 가능

---

## 7. 두 접근법 비교 요약(표 8-3 느낌)

| 방법          | 장점                  | 단점                    | 비고               |
| ----------- | ------------------- | --------------------- | ---------------- |
| 해시 기반       | longUrl만으로 키 계산 가능  | 해시 충돌 처리 필요, 구현 복잡    | 완전 분산 계산 가능      |
| ID + Base62 | 충돌 없음, 구현 단순, 관리 쉬움 | ID 생성기 필요, 중앙 의존성 가능성 | 실무에서 가장 흔히 쓰는 방식 |

---

## 8. 단축기 전체 플로우

### 8.1 URL 단축 플로우

1. 클라이언트가 longUrl을 들고 `POST /api/v1/urls/shorten` 요청
2. 서버는 longUrl 유효성 검사
3. 캐시 또는 DB에서 longUrl 검색

   * 이미 같은 URL이 존재하면 기존 shortUrl 반환
4. 없으면

   * 새 id 생성 (DB insert 또는 분산 ID 생성기)
   * id를 Base62로 변환 → shortKey
   * id, shortKey, longUrl을 DB에 저장
5. 응답으로 shortUrl(`https://sho.rt/{shortKey}`) 반환

해시 기반 방식을 쓰면 3~4 단계에서 해시 → 충돌 체크 플로우로 바꾸면 된다.

### 8.2 리디렉션 플로우

1. 사용자가 브라우저에서 단축 URL 요청

   * 예: `GET https://sho.rt/Ab3xYz1`
2. 서버(또는 API 게이트웨이/리버스 프록시)는 shortKey = “Ab3xYz1” 추출
3. 캐시(Redis 등)에서 shortKey 조회

   * 있으면 바로 longUrl 반환
   * 없으면 DB 조회 후

     * longUrl 찾으면 캐시에 세팅하고 응답
4. 301 또는 302 응답 + Location: longUrl 헤더로 리디렉션

읽기가 압도적으로 많으므로, shortKey → longUrl 매핑을 캐시에 올려두는 것이 중요하다.

---

## 9. 고가용성, 확장성 관점

* 데이터 저장

  * RDB 샤딩 + 안정 해시, 혹은 NoSQL(KV 스토어) 사용
* 캐시

  * Redis Cluster 등으로 분산 캐시 구성
* API 서버

  * 무상태(stateless)로 설계하고, 로드밸런서 뒤에 다중 인스턴스로 띄우기
* 통계/로그

  * 리다이렉션 요청 로그를 별도 큐(Kafka 등)에 비동기 전송
  * 실시간/배치 분석 시스템에서 클릭 수, referrer, user-agent 분석

---

## 10. 마무리

정리하면, URL 단축기는:

* write는 상대적으로 적고, read가 매우 많은 전형적인 읽기 중심 서비스이고
* 핵심은 다음 세 가지다.

  1. 충돌 없이 짧은 키를 만드는 전략(ID + Base62 또는 해시)
  2. 301/302 리다이렉션 정책과 캐시 전략
  3. 대량 데이터(수십 TB)와 트래픽을 견딜 수 있는 분산 저장/캐시 구조