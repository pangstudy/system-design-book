# 5장. 안정 해시 설계 (Consistent Hashing)

## 1. 해시 키 재배치 문제

### 1.1 단순 모듈러 방식

* 서버 수: N
* 키: k
* 서버 선택: `hash(k) % N`

이 방식은 간단하지만:

* 서버가 죽어서 N → N-1 이 되면, 대부분의 키에 대해 `hash(k) % (N-1)` 결과가 달라져서
  거의 모든 키가 다른 서버로 이동한다.
* 서버를 하나 추가해 N → N+1 이 되면, 마찬가지로 대부분의 키가 재배치된다.

→ 수평 확장/축소(서버 추가·삭제) 시 키 재배치 비용이 너무 크다.

---

## 2. 안정 해시 기본 개념

### 2.1 안정 해시란?

* 해시 테이블 크기(= 서버 수)가 변해도
  전체 키 중 “대략 k/n 정도만” 재배치되도록 설계한 해싱 기법.
* 서버 증감 시 전체 키를 다시 분배하지 않고, 영향 범위를 최소화하는 것이 목표.

### 2.2 해시 공간과 해시 링

* 해시 함수: `H(x)` 결과를 큰 정수 공간(예: 0 ~ 2³²-1)에 매핑.
* 이 공간을 “원형 링(circle)”으로 본다 → 해시 링(hash ring).
* 키와 서버를 모두 이 링 위의 한 점으로 본다.

### 2.3 서버 배치 (해시 서버)

* 모듈러 연산(`% N`)은 사용하지 않는다.
* 서버 ID(예: “s0”)에 해시 함수 적용:

  * `pos = H("s0")`
  * 이 pos를 링 위의 위치로 사용한다.

### 2.4 키 조회·저장

* 키 문자열(예: “user123”)에 해시 함수 적용:

  * `pos = H("user123")`
* 링을 시계방향으로 탐색하면서 만나는 “첫 번째 서버”가 이 키의 담당 서버.
* 조회/저장 모두 같은 방식으로 서버를 찾는다.

---

## 3. 서버 추가·제거와 재배치

### 3.1 서버 추가

* 새 서버 “s4” 추가 시:

  * `pos = H("s4")` 를 링에 추가.
  * 링에서 “이전 서버(s_prev) 위치”와 “s4 위치” 사이에 있는 키들만
    기존 서버에서 s4로 옮기면 된다.
* 따라서, 전체 키의 일부(이론상 최대 k/n 정도)만 재배치된다.

### 3.2 서버 제거

* 서버 “s2” 제거 시:

  * s2가 담당하던 구간의 키들만 다음 서버로 이동.
* 나머지 키는 그대로 유지되므로 재배치 비용이 작다.

---

## 4. 기본 구현의 두 가지 문제

기본 안정 해시 절차:

1. 서버와 키에 같은 해시 함수 사용 (균등 분포 가정)
2. 키의 위치에서 링을 시계방향으로 탐색하며 최초로 만나는 서버에 할당

이 기본 형태에는 두 가지 문제가 있다.

### 4.1 파티션 크기 불균형

* 서버들 위치가 랜덤이므로, 서버 간 간격이 들쭉날쭉하다.
* 어떤 서버는 넓은 구간, 어떤 서버는 좁은 구간을 담당하게 될 수 있다.
* 서버 하나 추가/삭제 시, 어떤 서버는 거의 2배 일감을 떠맡게 되는 상황 발생.

### 4.2 키 균등 분포 어려움

* 실제 해시 결과가 완벽히 균등하지 않으면,
  링 위의 특정 서버 근처에 키가 몰릴 수 있다.
* 극단적으로는 대부분의 키가 특정 서버에만 집중되는 상황도 가능하다.

---

## 5. 가상 노드(Virtual Node)로 해결

### 5.1 가상 노드 개념

* 각 물리 서버를 여러 개의 “가상 노드”로 쪼개서 링에 흩뿌리는 방식.

* 예: 서버 4개(s0, s1, s2, s3), 가상 노드 3개씩

  * s0_0, s0_1, s0_2
  * s1_0, s1_1, s1_2
  * s2_0, s2_1, s2_2
  * s3_0, s3_1, s3_2

* 각 가상 노드에 대해

  * `pos = H("s0#0")`, `H("s0#1")`, … 처럼 해시를 다시 계산해서
    링 위의 여러 위치로 분산시킨다.

* 키는 여전히 “시계방향 첫 서버”를 찾되, 그 서버의 “가상 노드를 통해” 실제 물리 서버를 참조한다.

### 5.2 질문: 가상 노드의 해시링 배치는 어떻게 되나요?

질문에서 말한 “s0_0, s1_0, s2_0, s3_0, s0_1, s1_1 … 이런 순서로 배치되나요?”

* 실제 구현에서는 “순서대로 배치”하지 않는다.
* 일반적인 구현 방식:

  * 각 (서버, 가상 노드) 조합을 문자열로 만든다.

    * 예: `"s0-0"`, `"s0-1"`, `"s1-0"`, …
  * 각각에 해시 함수를 적용해 “해시값”을 얻는다.
  * 이 해시값을 기준으로 링 위에 “정렬”한다.
* 즉, 해시 결과에 따라 s0_0, s1_0, s2_0,... 이 랜덤하게 섞여 링 전체에 퍼지게 된다.
* 이때 해시 함수가 균등 분포를 잘 만들어 준다는 가정 하에:

  * 가상 노드들을 많이 두면 둘수록 각 서버가 담당하는 구간 길이가 “평균에 수렴”한다.
  * 그래서 키 분포가 점점 더 균등해진다.

### 5.3 가상 노드 개수와 분포

* 가상 노드를 늘릴수록:

  * 각 서버가 담당하는 총 구간 길이의 표준 편차가 줄어든다.
  * 예시:

    * 서버당 가상 노드 100개 → 편차 약 10% 수준
    * 서버당 가상 노드 200개 → 편차 약 5% 수준
* 가상 노드 수는 시스템 규모 및 허용 오버헤드를 고려해 정한다.

---

## 6. 재배치할 키 결정 (서버 추가 예시)

* s4 서버 추가:

  * s4의 각 가상 노드(s4_0, s4_1, …)에 대해 해시 값을 계산하고 링에 삽입.
  * 각 가상 노드 위치 기준으로:

    * “직전 가상 노드”와 “s4_x” 사이에 있는 키들을 s4로 옮긴다.
* 즉, 새 서버의 가상 노드가 막아서는 구간에 있는 키들만 재배치하면 된다.
* 덕분에 전체 키 중 일부만 이동하고, 나머지는 그대로 유지된다.

---

## 7. 마무리 요약

* 안정 해시는 “서버 수 변화 시 키 재배치 최소화”와 “균등 분산”을 동시에 노린 설계이다.
* 모듈러 방식 대비 장점

  * 서버 추가/삭제 시 전체 키를 재배치하지 않고, 최대 k/n 정도만 이동
  * 데이터가 링 전체에 고르게 분포해 수평 확장이 쉽고, 특정 서버에 트래픽이 몰리는 핫스팟 문제 완화
* 핵심 아이디어

  * 키와 서버(가상 노드 포함)를 하나의 해시 링 위에 올려놓고
  * “시계 방향 첫 서버”가 키를 담당하도록 하는 구조
  * 가상 노드로 서버 구간을 잘게 쪼개고, 해시를 통해 링 전체에 고르게 분산