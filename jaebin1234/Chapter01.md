# 1장: 사용자 수에 따른 규모 확장성

---

## 단일 서버
- 설명: 가장 단순한 형태의 시스템 아키텍처로, 웹 서버, 데이터베이스, 캐시 등 모든 컴포넌트가 하나의 서버에서 실행되는 방식입니다. 초기 단계의 웹 서비스나 사용자 수가 매우 적은 경우에 적합합니다.

### 사용자 요청 처리 흐름
- 설명: 사용자가 웹 브라우저나 모바일 앱을 통해 특정 웹사이트나 서비스에 접근할 때, 내부적으로 어떤 과정들이 발생하는지를 보여줍니다.

1. 도메인 입력 (예: `www.example.com`): 사용자가 브라우저 주소창에 도메인 이름을 입력하거나, 앱에서 특정 링크를 클릭합니다.
2. DNS (Domain Name System) 쿼리: 브라우저/앱은 DNS 서버에 `www.example.com`의 IP 주소를 묻습니다. DNS는 "인터넷의 전화번호부"와 같습니다.
3. IP 주소 반환: DNS 서버는 `www.example.com`에 해당하는 Public IP 주소 (예: `15.1.2.3`)를 클라이언트에게 반환합니다.
4. 웹 서버 연결: 클라이언트는 반환받은 IP 주소를 사용하여 해당 웹 서버에 HTTP 요청을 보냅니다.
5. 웹 서버 처리: 웹 서버는 요청을 받아 웹 페이지(HTML), 이미지, JSON 데이터 등의 HTTP 응답을 생성하여 클라이언트에게 다시 보냅니다.      

❓질문
- 단일 서버 구조의 장점은 무엇이며, 사용자 수가 증가함에 따라 어떤 문제가 발생할 수 있을까요?
  - 장점
    - 초기 개발 및 배포가 간단, 유지보수 용이, 인프라 비용이 저렴
  - 문제점
    - 서버 한 대에 장애가 발생하면 서비스 전체가 중단(SPOF)
    - 확장성이 부족 (트래픽 증가에 취약)
    - 컴포넌트별 독립적 업그레이드/운영이 어려움

## 데이터 베이스
- 설명: 시스템에서 데이터를 영구적으로 저장하고 관리하는 핵심 컴포넌트입니다. 사용자 정보, 상품 목록, 주문 내역 등 모든 중요한 데이터가 데이터베이스에 저장됩니다.
- 단일 서버 아키텍처에서 웹 서버와 데이터베이스가 분리된 형태로 확장되는 첫 단계입니다. 웹 서버는 사용자 요청을 처리하고, 데이터베이스는 데이터 저장 및 관리를 전담합니다.

### 어떤 데이터베이스를 이용할 것인가?
- **RDBMS (관계형 데이터베이스 시스템)**: 관계형 모델을 기반으로 데이터를 테이블 형태로 저장합니다. SQL(Structured Query Language)을 사용하여 데이터를 조작합니다.
    - **장점**:
        - 데이터 일관성 및 무결성: ACID(원자성, 일관성, 고립성, 지속성) 속성을 강력하게 보장하여 데이터의 신뢰성이 높습니다.
        - 정형화된 데이터 관리: 데이터 스키마가 명확하여 구조화된 데이터 관리에 적합합니다.
        - 조인 기능: 여러 테이블 간의 복잡한 관계를 조인을 통해 쉽게 처리할 수 있습니다.
    - **단점**:
        - **수평적 확장성 제한**: 일반적으로 수직적 확장에 의존하며, 대규모 트래픽 분산 및 샤딩이 복잡합니다.
        - **스키마 변경의 어려움**: 스키마 변경 시 전체 시스템에 영향을 미칠 수 있습니다.
        - **비정형 데이터 저장의 어려움**: 이미지, 동영상 등 비정형 데이터를 효율적으로 저장하기 어렵습니다.
    - **예시**: MySQL, PostgreSQL, Oracle, SQL Server.
- **NoSQL (Not Only SQL)**: 관계형 모델 외의 다양한 모델(키-값, 문서, 칼럼, 그래프 등)로 데이터를 저장합니다. 비정형/반정형 데이터, 대규모 분산 환경에 강점을 가집니다.
    - **장점**:
        - 낮은 응답시간, 비정형이라 관계형 데이터가 아님, 데이터를 직렬화 하거나 역직렬화 할 경우, 아주 많은 양의 데이터를 저장할 필요가 있을 경우
        - **수평적 확장성**: 데이터를 여러 서버에 분산 저장하여 대규모 트래픽과 데이터 처리에 용이합니다.
        - **유연한 스키마**: 스키마 없이 데이터를 저장하거나 유연하게 변경할 수 있어, 데이터 구조 변경에 용이합니다.
        - **높은 가용성 및 성능**: 분산 처리를 통해 빠른 응답 속도와 높은 가용성을 제공합니다.
    - **단점**:
        - **데이터 일관성 제약**: 대부분의 NoSQL은 최종 일관성(Eventual Consistency)을 제공하며, ACID 속성을 강력하게 보장하지 않습니다.
        - **복잡한 쿼리 제한**: 관계형 데이터베이스의 조인과 같은 복잡한 쿼리 기능이 제한적이거나 없습니다.
        - **데이터 모델링의 어려움**: 데이터 모델링에 대한 새로운 접근 방식이 필요합니다.
    - **예시**: MongoDB (문서), Cassandra (칼럼), Redis (키-값), Neo4j (그래프).

❓질문
- 서비스의 데이터가 주로 정형화되어 있고 데이터 일관성이 매우 중요한 경우, 어떤 데이터베이스 유형을 선택하는 것이 좋을까요? 반대로, 데이터 구조가 유동적이고 빠른 확장성이 중요한 경우에는요?
  - 정형화 되어있고, 데이터 일관성이 매우 중요한 경우는 RDBMS
  - 데이터 구조가 유동적이고, 빠른 확정성, 낮은 응답시간이 필요할 경우는 NOSQL

## 수직적 규모 확장 vs 수평적 규모 확장

- **수직적 규모 확장 (Scale Up)**: 단일 서버의 하드웨어 성능(CPU, RAM, 디스크)을 업그레이드하여 처리량을 늘리는 방식입니다.
    - **장점**: 아키텍처 변경 없이 성능 향상 가능, 구현이 비교적 단순.
    - **단점**: 물리적인 한계가 존재하고, 비용이 매우 비싸며, 단일 서버 장애 시 전체 서비스가 중단되는 **단일 장애점(SPOF)**이 됩니다.
    - **스케일 업의 한계**: 아무리 좋은 서버라도 처리할 수 있는 트래픽과 저장할 수 있는 데이터의 양에는 물리적인 한계가 있습니다. 예를 들어, 128GB RAM 이상의 서버를 찾는 것은 쉽지 않고, 그 비용도 매우 비쌉니다.
- **수평적 규모 확장 (Scale Out)**: 여러 대의 서버를 추가하여 시스템의 처리량을 늘리는 방식입니다.
    - **장점**: 이론적으로 무한대에 가까운 확장이 가능하며, 비용 효율적이고, 한 서버의 장애가 전체 서비스 중단으로 이어지지 않아 **고가용성**을 제공합니다.
    - **단점**: 시스템 복잡도가 증가하고, 분산 시스템 고유의 문제(데이터 일관성, 통신 오버헤드 등)를 해결해야 합니다.

### 로드 밸런서
- 부하 분산이란?: 여러 서버에 네트워크 트래픽을 효율적으로 분배하여, 특정 서버에 과부하가 걸리는 것을 방지하고, 시스템의 안정성과 가용성을 높이는 기술입니다.

#### 로드 밸런서의 동작예시
- 사용자의 요청이 로드 밸런서의 **Public IP**로 들어옵니다.
- 로드 밸런서는 등록된 여러 웹 서버(예: 웹 서버 1, 웹 서버 2, 웹 서버 3)의 **Private IP**를 알고 있으며, 이들 서버의 부하 상태, 응답 시간 등을 고려하여 요청을 최적의 서버로 전달합니다.
- 웹 서버는 요청을 처리한 후 로드 밸런서를 통해 클라이언트에게 응답을 보냅니다.
- **예시**: 클라우드 환경에서 AWS ELB (Elastic Load Balancer)나 Nginx 같은 소프트웨어 로드 밸런서를 사용합니다.

#### Public IP와 Private IP란? 그리고 차이점
- **Public IP (공인 IP)**: 인터넷 상에서 유일하게 식별되는 IP 주소입니다. 외부에 공개되어 있어 인터넷을 통해 직접 접근할 수 있습니다. 로드 밸런서나 방화벽에 할당되어 외부 트래픽을 받습니다.
    - **예시**: `15.1.2.3`
- **Private IP (사설 IP)**: 특정 네트워크(예: 회사 내부망, 클라우드 VPC) 내에서만 유효한 IP 주소입니다. 외부에 직접 노출되지 않으며, 내부 통신에 사용됩니다. 웹 서버, 데이터베이스 서버 등에 할당됩니다.
    - **예시**: `10.0.0.1`, `172.16.0.1`, `192.168.0.1`
- **차이점**: Public IP는 전 세계 인터넷에서 고유하고 직접 접근 가능하지만, Private IP는 특정 사설 네트워크 내에서만 사용되며 외부에서 직접 접근하려면 NAT(Network Address Translation) 등의 추가 설정이 필요합니다. 로드 밸런서는 Public IP를 통해 외부 요청을 받고, 내부 Private IP를 가진 서버들로 트래픽을 분산합니다.

❓질문
- 로드 밸런서가 트래픽을 분산하는 '최적의 서버'를 선택하는 기준에는 어떤 것들이 있을까요? (예: 라운드 로빈, 최소 연결 등)
  - 라운드 로빈(Round Robin): 순서대로 각 서버에 요청을 분배
  - 최소 연결(Least Connections): 현재 연결 수가 가장 적은 서버에 분배
  - IP 해시(IP Hash): 클라이언트 IP를 해싱해서 특정 서버에 고정 분배
  - 가중 라운드 로빈(Weighted Round Robin): 서버마다 가중치를 부여해 분배 비율 조정
  - 가중 최소 연결(Weighted Least Connections): 가중치와 연결 수를 모두 고려해 분배
  - 응답 시간(Response Time): 응답이 가장 빠른 서버에 분배
  - 랜덤(Random): 무작위로 서버를 선택하여 분배
  - URL/Path 기반: 요청의 URL이나 Path에 따라 서버를 지정해 분배
  - 서버 상태/헬스 체크 기반: 서버의 상태(헬스체크 결과)에 따라 정상 서버에만 분배

### 데이터베이스 다중화
- 설명: 데이터베이스의 가용성과 읽기 성능을 향상시키기 위해 동일한 데이터를 여러 데이터베이스 서버에 복제하여 유지하는 기술입니다.
- **마스터(주) - 슬레이브(부) 구조 (Master-Slave Replication)**:
    - **개념**: 하나의 마스터 데이터베이스가 모든 쓰기(Write) 작업을 처리하고, 변경된 데이터를 하나 이상의 슬레이브(읽기 전용) 데이터베이스로 복제(Replicate)하는 구조입니다. 슬레이브는 주로 읽기(Read) 요청을 처리합니다.
    - **쓰기와 읽기의 분산**:
        - **쓰기**: 모든 쓰기 요청은 마스터 데이터베이스로만 향합니다.
        - **읽기**: 읽기 요청은 마스터와 슬레이브 데이터베이스로 분산될 수 있습니다. 일반적으로 슬레이브 서버가 여러 개 있으므로 읽기 부하를 효과적으로 분산할 수 있습니다.
    - **장점**:
        - **성능 향상**: 읽기 요청을 슬레이브로 분산하여 마스터의 부하를 줄이고 전체 시스템의 처리량을 늘립니다.
        - **고가용성**: 마스터 서버가 다운되더라도 슬레이브 중 하나를 새로운 마스터로 승격시켜 서비스 중단을 최소화할 수 있습니다.
        - **데이터 백업**: 슬레이브 서버에서 백업을 수행하여 마스터의 성능 저하를 방지할 수 있습니다.
    - **단점**:
        - **쓰기 확장성 제한**: 모든 쓰기 요청이 마스터에 집중되므로, 쓰기 작업이 많은 애플리케이션에서는 마스터가 병목 현상이 될 수 있습니다.
        - **복제 지연 (Replication Lag)**: 마스터의 데이터 변경이 슬레이브에 반영되기까지 약간의 시간 지연이 발생할 수 있습니다. 이로 인해 슬레이브에서 읽는 데이터가 최신이 아닐 수 있습니다.
        - **단일 장애점 (SPOF)**: 마스터가 다운되면 새로운 마스터를 수동 또는 자동으로 승격시켜야 합니다.
    - **주 서버가 다운된 경우 (마스터 장애)**: 슬레이브 중 하나를 수동 또는 자동(예: Redis Sentinel, MySQL MGR)으로 새로운 마스터로 승격시킵니다. 이 과정 동안 쓰기 작업이 일시적으로 중단될 수 있습니다.
    - **부 서버가 다운된 경우 (슬레이브 장애)**: 해당 슬레이브만 서비스에서 제외되고, 마스터와 다른 슬레이브들은 정상적으로 작동합니다. 복구 후 다시 마스터에 연결하여 데이터를 동기화합니다.

❓질문
- 마스터-슬레이브 데이터베이스 구조에서 '복제 지연'이 발생했을 때, 애플리케이션 레벨에서 이를 어떻게 처리하거나 완화할 수 있을까요?
  - 쓰기 이후 읽기는 마스터에서 처리(Read-after-write to Master): 데이터 변경 직후에는 반드시 마스터 DB에서 읽어 일관성 보장
  - 일정 시간(Delay) 후 슬레이브 조회: 쓰기 직후 바로 읽지 않고, 일정 시간 대기 후 슬레이브에서 읽기
  - 쓰기/읽기 요청 라우팅 제어: 트랜잭션 내 읽기는 모두 마스터에서 처리, 일반 조회만 슬레이브 사용
  - 애플리케이션 캐시 사용: 쓰기 직후 데이터를 캐시에 저장하고, 캐시 우선 조회

### 캐시
캐시란?: 자주 참조되는 데이터나 계산 결과를 임시 저장하는 고속 저장소입니다. 데이터베이스나 API 호출과 같이 느린 원본 데이터 소스에 대한 접근 비용을 줄여 시스템 성능을 향상시킵니다. '자주 참조되는 데이터를 메모리 안에 둠'으로써 빠르게 접근할 수 있게 합니다.

#### 캐시 계층
- **캐시 계층**: 시스템 아키텍처에서 캐시 서버가 별도의 계층으로 분리되어 존재하는 것을 의미합니다.
    - **보통 캐시 계층은 어디에 있나?**:
        - **클라이언트 측 캐시**: 웹 브라우저 캐시 (정적 파일: 이미지, CSS, JS).
        - **CDN (콘텐츠 전송 네트워크)**: 지리적으로 분산된 서버에 정적 콘텐츠를 캐시.
        - **웹 서버/애플리케이션 서버 앞단**: 로드 밸런서와 웹 서버 사이에 위치하여 자주 요청되는 페이지나 API 응답을 캐시. (예: Nginx reverse proxy cache)
        - **애플리케이션 서버 자체**: 애플리케이션 내부에 메모리 캐시 (인메모리 캐시).
        - **별도의 캐시 서버**: 웹 서버와 데이터베이스 사이에 위치하는 분산 캐시 시스템 (예: Memcached, Redis). 가장 일반적인 형태입니다.

#### 캐시 전략
- Cache Aside (Lazy Loading, 수동 캐시 패턴): 애플리케이션이 캐시를 직접 제어, 캐시에 데이터가 없으면 → DB에서 읽고 → 애플리케이션이 직접 캐시에 저장
- 우선 읽기 전략 (Read-Through): 애플리케이션이 캐시에서 데이터를 읽으려 할 때, 데이터가 캐시에 없으면 캐시 시스템이 직접 원본 데이터베이스에서 데이터를 가져와 캐시에 저장한 후 애플리케이션에 반환하는 방식입니다. 애플리케이션은 항상 캐시만 바라봅니다.
- Write Through : 데이터를 캐시에 쓸 때 DB에도 동시에 즉시 기록하는 캐시 갱신 방식

#### 캐시 사용의 유의할 점
- **갱신은 자주 일어나지 않지만, 참조가 빈번하게 일어나는 경우**: 
  - 캐시 사용에 가장 적합한 시나리오입니다. 예를 들어, 웹사이트의 메인 페이지에 표시되는 인기 상품 목록이나 설정 값 등이 해당됩니다.
- **캐시 데이터의 만료 (Expiration)**: 
  - 캐시된 데이터가 언제까지 유효한지 설정하는 것입니다. '만료 정책'은 `TTL (Time-To-Live)` 기반(일정 시간 후 만료) 또는 `LRU (Least Recently Used)` 기반(가장 오랫동안 사용되지 않은 데이터부터 삭제) 등이 있습니다. 만료되면 캐시에서 데이터가 삭제되고, 다음 요청 시 원본에서 다시 가져옵니다.
- **캐시 데이터의 일관성 유지**: 
  - 원본 데이터가 변경되었을 때 캐시 데이터도 즉시 업데이트되거나 무효화되어야 합니다. 그렇지 않으면 오래된 데이터가 클라이언트에게 제공될 수 있습니다. `Write-Through`, `Write-Back`, `Cache-Aside` 등 다양한 캐시 무효화 전략이 있습니다.
- **캐시 서버를 한대만 둘 때 SPOF (단일 장애 지점)이 되버릴 가능성**: 
  - 단일 캐시 서버가 다운되면 해당 캐시를 사용하는 모든 서비스가 영향을 받을 수 있습니다. 따라서 캐시 서버도 다중화(클러스터링)하여 SPOF를 제거해야 합니다 (예: Redis Cluster).
- **캐시 메모리는 얼마나 잡을까?**: 
  - 캐시할 데이터의 양, 예상되는 트래픽, 비용 등을 고려하여 결정합니다. 너무 적으면 캐시 히트율이 낮아지고, 너무 많으면 비용이 증가합니다.
- **데이터 방출 (Eviction) 정책이란?**: 
  - 캐시 메모리가 가득 찼을 때, 어떤 데이터를 삭제하여 새로운 데이터를 저장할 공간을 확보할 것인지 결정하는 정책입니다. `LRU (Least Recently Used)`, `LFU (Least Frequently Used)`, `FIFO (First-In, First-Out)` 등이 일반적입니다.

❓질문
- 캐시를 도입할 때 가장 중요하게 고려해야 할 사항은 무엇이며, 캐시 일관성 문제를 해결하기 위한 일반적인 방법 두 가지를 설명해주세요.
  - 캐시 도입 시 가장 중요한 고려사항: 데이터 일관성(Consistency)과 동기화 방법이 가장 중요합니다.
  - 캐시 일관성 문제 해결 방법(대표 2가지)
    - 만료/무효화(Expiration/Invalidate): 데이터 변경 시 캐시를 삭제(무효화)하거나, 일정 시간이 지나면 자동으로 만료되도록 설정
    - 쓰기 갱신(Write-through / Write-back): DB에 데이터가 변경될 때마다 캐시도 즉시 함께 갱신하거나, 변경 내역을 캐시에 먼저 반영한 뒤 주기적으로 DB에 동기화

### 콘텐츠 전송 네트워크 CDN
- CDN (Content Delivery Network)이란?: 지리적으로 분산된 여러 서버(PoP, Point of Presence)에 정적 콘텐츠(이미지, CSS, JavaScript, 비디오 파일 등)를 캐시하고, 사용자에게 가장 가까운 서버에서 콘텐츠를 전송함으로써 콘텐츠 로딩 속도를 향상시키고 원본 서버의 부하를 줄이는 서비스입니다. '정적 콘텐츠 데이터 캐시'의 대표적인 예시입니다.
- 그럼 브라우저 단인가?: CDN은 브라우저 캐싱과 비슷하게 동작하지만, 브라우저 캐싱은 사용자 개별 브라우저에 저장되는 반면, CDN은 **중간 서버(엣지 서버)**에 캐시되어 여러 사용자에게 공유됩니다. 즉, 브라우저보다 훨씬 넓은 범위의 '캐시'라고 볼 수 있습니다.

#### CDN 동작 예시
- 사용자가 웹사이트의 정적 콘텐츠(예: 이미지 `logo.png`)를 요청합니다.
- 이 요청은 DNS를 통해 CDN의 엣지 서버(사용자에게 가장 가까운)로 라우팅됩니다.
- 엣지 서버에 `logo.png`가 캐시되어 있다면, 즉시 사용자에게 전송합니다.
- 엣지 서버에 `logo.png`가 없다면, 엣지 서버는 원본 서버에 요청하여 `logo.png`를 가져온 후 캐시하고 사용자에게 전송합니다. 이후 동일한 요청이 들어오면 엣지 서버에서 직접 응답합니다.

#### CDN 사용 시 고려해야 할 사항
- **비용**: CDN 사용량(데이터 전송량, 요청 수)에 따라 비용이 발생합니다.
- **적절한 만료 시한**: 캐시된 콘텐츠의 만료 시간을 적절하게 설정해야 합니다. 너무 길면 업데이트된 콘텐츠가 반영되지 않을 수 있고, 너무 짧으면 캐시 효율이 떨어집니다.
- **CDN 장애 대처 방안**: CDN 서비스 자체에 장애가 발생했을 때, 원본 서버로 직접 트래픽을 우회하는 등의 비상 계획이 필요합니다.
- **콘텐츠 무효화 방법 (Invalidation)**: 원본 콘텐츠가 변경되었을 때, CDN에 캐시된 오래된 콘텐츠를 강제로 삭제하거나 갱신하는 방법입니다. 수동 무효화, URL 기반 무효화, 태그 기반 무효화 등이 있습니다.

### 무상태(stateless) 웹 계층
- 설명: 웹 서버(웹 계층)가 클라이언트의 상태 정보(예: 로그인 여부, 쇼핑 카트 내용)를 자체적으로 저장하지 않고, 모든 요청을 독립적으로 처리하는 아키텍처 방식입니다.
- 상태 정보 의존적인 아키텍처
  - 사용자의 세션 정보가 특정 웹 서버의 메모리에 저장되는 경우입니다.
  - **단점**:
    - **확장성의 어려움**: 사용자가 처음 접속했던 웹 서버가 아닌 다른 웹 서버로 요청이 전달되면, 해당 서버에는 세션 정보가 없으므로 로그아웃되거나 오류가 발생할 수 있습니다. 따라서 특정 서버에만 요청이 고정(Sticky Session)되어야 하므로 로드 밸런싱 효율이 떨어집니다.
    - **단일 장애점**: 세션 정보를 가진 웹 서버가 다운되면 해당 사용자의 세션 정보가 유실되어 서비스에 문제가 생깁니다.
    - **유지보수 및 배포의 복잡성**: 서버를 추가하거나 제거하기 어렵고, 새로운 버전을 배포할 때 세션 유지를 위한 복잡한 전략이 필요합니다.
- 무상태 아키텍처 (Stateless Architecture):
  - 클라이언트의 상태 정보(세션 데이터 등)를 웹 서버 자체에 저장하지 않고, 외부에 있는 공유 저장소에 저장하는 방식입니다.
  - - **장점**:
    - **수평적 확장 용이**: 어떤 웹 서버로 요청이 들어오든 공유 저장소에서 상태 정보를 가져올 수 있으므로, 웹 서버를 자유롭게 추가하거나 제거할 수 있습니다.
    - **고가용성**: 특정 웹 서버가 다운되어도 사용자의 세션 정보는 공유 저장소에 안전하게 보관되므로 서비스 연속성이 보장됩니다.
    - **유지보수 및 배포 용이**: 서버 교체, 업데이트 등이 훨씬 단순해집니다.

❓질문
- 무상태 웹 계층의 가장 큰 장점은 무엇이며, 이 아키텍처를 구현하기 위해 어떤 기술이 필수적으로 사용되어야 할까요?
  - 확장성과 유연성이 높다(서버를 쉽게 늘릴 수 있고, 특정 서버에 종속되지 않음)
  - 세션 데이터의 외부 저장소(예: Redis, Memcached 등 분산 캐시) 또는 JWT 같은 토큰 기반 인증에서 사용

### 자동 규모 확장 (Auto Scaling)
- 설명: 트래픽 부하나 사용량 변화에 따라 웹 서버나 다른 컴퓨팅 자원을 자동으로 추가하거나 삭제하여, 성능 저하 없이 비용 효율적으로 시스템을 운영하는 기술입니다.
- 트래픽에 따라 웹 서버를 자동으로 추가하거나 삭제
  - **예시**: 클라우드 환경에서 AWS Auto Scaling Group, Google Cloud Autohealing, Azure Virtual Machine Scale Sets 등을 사용합니다.
  - CPU 사용률, 네트워크 I/O, 요청 지연 시간 등 미리 정의된 지표가 임계값을 초과하면 서버 인스턴스를 자동으로 늘리고(스케일 아웃), 지표가 안정화되면 다시 줄입니다(스케일 인).

### 데이터 센터
- 설명: 물리적으로 분리된 여러 지역에 서버, 네트워크 장비, 스토리지 등 IT 인프라를 모아둔 시설입니다. 대규모 시스템은 단일 데이터 센터의 장애에 대비하고, 사용자에게 더 낮은 지연 시간을 제공하기 위해 여러 데이터 센터를 사용합니다.
- 지리적 라우팅: 사용자의 지리적 위치에 따라 가장 가까운 데이터 센터로 트래픽을 라우팅하는 기술입니다. 이를 통해 서비스 응답 시간을 단축하고, 지역적 네트워크 문제에도 대비할 수 있습니다. DNS 레코드(예: Latency-based Routing)를 통해 구현됩니다.
- 동작 예시:
  - 사용자는 DNS를 통해 가장 가까운 데이터 센터로 라우팅됩니다.
  - 각 데이터 센터는 자체적인 로드 밸런서, 웹 서버, 데이터베이스 등을 가지고 있습니다.
  - **트래픽 우회**: 한 데이터 센터에 장애가 발생하면, DNS 설정을 변경하여 모든 트래픽을 다른 정상적인 데이터 센터로 우회시킬 수 있습니다.
  - **데이터 동기화**: 여러 데이터 센터 간에 데이터 일관성을 유지하기 위해 데이터베이스 복제 또는 동기화 메커니즘이 필요합니다. 이는 복잡하고 어려운 작업입니다 (예: Active-Active 또는 Active-Passive 복제).

### 메시지 큐
- 메시지 큐란?: 독립적인 컴포넌트 또는 서비스 간에 메시지를 비동기적으로 교환할 수 있도록 해주는 버퍼 역할을 하는 시스템입니다. '큰 규모의 확장'과 '독립적'인 처리를 가능하게 합니다.
- 비동기 통신: 메시지를 즉시 처리하지 않고 큐에 넣어두면, 메시지 수신자가 나중에 꺼내서 처리합니다. 이로 인해 송신자는 응답을 기다리지 않고 다음 작업을 진행할 수 있습니다.
- 버퍼 역할: 갑작스러운 트래픽 증가로 인해 서비스가 과부하될 경우, 메시지 큐가 요청을 일시적으로 저장하여 시스템이 안정적으로 처리할 수 있도록 도와줍니다.
- **발행자 (Publisher)와 구독자 (Subscriber, 소비자)**:
    - **발행자**: 메시지를 생산하여 큐에 넣는 컴포넌트입니다.
    - **구독자 (소비자)**: 큐에서 메시지를 가져와 처리하는 컴포넌트입니다.
    - **예시**: 사용자 회원가입 시, 웹 서버(발행자)는 '사용자 가입' 메시지를 큐에 넣고, 이메일 발송 서비스(구독자), 통계 처리 서비스(구독자) 등 여러 서비스가 이 메시지를 구독하여 각자의 작업을 비동기적으로 수행합니다.
- **장점**:
    - **결합도 감소**: 서비스 간의 의존성을 줄여 각 서비스가 독립적으로 개발, 배포, 확장될 수 있게 합니다.
    - **내결함성**: 일부 서비스에 장애가 발생하더라도 전체 시스템에 미치는 영향을 최소화합니다.
    - **확장성**: 발행자와 구독자 수를 독립적으로 늘려 부하를 분산할 수 있습니다.

### 로그, 메트릭 그리고 자동화
- **로그란?**: 시스템에서 발생하는 모든 이벤트(사용자 로그인, 에러 발생, 데이터베이스 쿼리 등)를 기록한 데이터입니다. 문제 해결, 보안 감사, 시스템 동작 분석에 사용됩니다.
- **메트릭이란?**: 시스템의 성능과 상태를 나타내는 수치 데이터입니다 (예: CPU 사용률, 메모리 사용량, 네트워크 I/O, 요청 처리량, 에러율, 응답 시간). 시스템의 건강 상태를 모니터링하고 병목 지점을 찾는 데 사용됩니다.
- **자동화란?**: 수동으로 반복되는 작업을 스크립트나 도구를 사용하여 자동으로 처리하는 것입니다 (예: 배포 자동화, 테스트 자동화, 인프라 프로비저닝 자동화). 이는 개발 및 운영 효율성을 높이고 인적 오류를 줄입니다.

### 데이터베이스의 규모 확장

#### 수평적 확장 (Scaling Out)
- **설명**: 여러 대의 데이터베이스 서버를 추가하여 데이터를 분산 저장하고 처리하는 방식입니다. 주로 **샤딩(Sharding)**을 통해 이루어집니다.
- **샤딩 (Sharding)**: 데이터를 여러 데이터베이스 서버(샤드)에 분할하여 저장하는 기술입니다. 각 샤드는 전체 데이터의 일부를 담당합니다.
    - **샤딩 키 전략 (파티션 키 전략)**: 데이터를 어떤 샤드에 저장할지 결정하는 기준이 되는 키(Column)를 선택하는 전략입니다.
        - **범위 기반 샤딩**: 특정 범위의 데이터를 특정 샤드에 할당 (예: 사용자 ID 1~1000은 샤드 A, 1001~2000은 샤드 B).
        - **해시 기반 샤딩**: 데이터의 해시 값을 계산하여 특정 샤드에 할당 (예: `hash(user_id) % num_shards`).
        - **디렉토리 기반 샤딩**: 별도의 룩업 테이블(디렉토리 서버)을 사용하여 어떤 데이터가 어떤 샤드에 있는지 매핑 정보를 관리합니다.
- **문제점 (샤딩의 도전 과제)**:
    - **데이터의 재 샤딩 (Re-Sharding)**: 데이터베이스 샤드의 수를 늘리거나 줄일 때, 기존 데이터를 재분배하는 과정입니다. 매우 복잡하고 시간이 많이 소요되며, 서비스 중단이 발생할 수 있습니다.
        - **샤드 소진**: 특정 샤드가 가득 차서 더 이상 데이터를 저장할 수 없는 상황입니다. 이 경우 리샤딩이 필요합니다.
    - **핫스팟 키 문제 (Hotspot Key Problem)**: 특정 샤드에 데이터나 트래픽이 비정상적으로 집중되는 현상입니다. 예를 들어, 매우 인기 있는 연예인의 게시물이나 특정 이벤트를 처리하는 데이터가 한 샤드에 몰릴 경우 발생합니다. 이는 해당 샤드의 성능 병목을 유발합니다.
    - **조인과 비정규화**:
        - **조인 (Join)**: 관계형 데이터베이스에서 여러 테이블의 데이터를 결합하는 연산입니다. 샤딩된 환경에서는 조인할 데이터가 서로 다른 샤드에 있을 수 있어 복잡성이 증가하고 성능 저하가 발생할 수 있습니다.
        - **비정규화 (Denormalization)**: 데이터베이스의 정규화 원칙을 일부러 위배하여 중복 데이터를 허용하는 대신, 쿼리 성능을 향상시키거나 조인을 줄이는 기법입니다. 샤딩된 환경에서 조인의 어려움을 극복하기 위해 사용되기도 합니다.
            - **예시**: 사용자 정보와 사용자 게시물 정보가 별도의 샤드에 있을 때, 게시물 테이블에 사용자 이름을 중복 저장하여 사용자 이름을 조회할 때 조인이 필요 없도록 하는 것입니다.

❓질문
-  핫스팟 키 문제를 완화하기 위한 샤딩 키 선택 전략에는 어떤 것들이 있을까요?
  - 랜덤 값(해시) 추가: 샤딩 키에 무작위 값이나 해시값을 더해 트래픽을 여러 샤드로 분산
  - 시간/순차 값 분리:타임스탬프 등 순차적인 값을 샤딩 키로 쓰지 않고, 분산 잘 되는 값”(ex: 무작위, 해시, 적절히 randomize된 userId 등) 등 분산 가능한 값을 샤딩 키로 선택
  - 복합 키(Composite Key) 사용: 사용자ID+날짜, 상품ID+카테고리 등 여러 필드를 조합하여 샤딩 키 생성
  - Consistent Hashing: 해시링 기반 샤딩으로 데이터 분포를 고르게 유지

### 백만 사용자, 그리고 그 이상
- **웹 계층은 무상태 계층으로 유지할 것**: 서버 확장 및 안정성 확보를 위해 세션 정보 등은 외부 공유 저장소에 보관해야 합니다.
- **모든 계층에 다중화(Duplication)를 도입할 것**: 단일 장애점을 없애고 시스템의 가용성을 높이기 위해 로드 밸런서, 웹 서버, 데이터베이스, 캐시 서버 등 모든 컴포넌트를 여러 개로 복제하고 분산해야 합니다.
- **가능한 한 많은 데이터를 캐시할 것**: 데이터베이스 부하를 줄이고 응답 시간을 단축하기 위해 CDN, 분산 캐시 등을 적극적으로 활용해야 합니다.
- **여러 데이터 센터를 지원할 것**: 지리적 재해나 지역적 네트워크 장애에 대비하고 사용자에게 낮은 지연 시간을 제공하기 위해 다중 데이터 센터 아키텍처를 구축해야 합니다.
- **정적 콘텐츠는 CDN을 통해 서비스할 것**: 이미지, CSS, JavaScript 등은 CDN을 통해 제공하여 원본 서버의 부하를 줄이고 콘텐츠 전송 속도를 높여야 합니다.
- **데이터 계층은 샤딩을 통해 그 규모를 확장할 것**: 데이터베이스의 용량 및 처리량 한계를 극복하기 위해 데이터를 여러 데이터베이스 서버에 분산 저장하는 샤딩을 도입해야 합니다.
- **각 계층은 독립적 서비스로 분할할 것 (마이크로서비스 아키텍처 지향)**: 시스템의 복잡도를 줄이고 각 서비스의 독립적인 개발, 배포, 확장을 가능하게 하기 위해 기능을 기준으로 서비스를 분할합니다.
- **시스템을 지속적으로 모니터링하고 자동화 도구들을 활용할 것**: 시스템의 건강 상태를 실시간으로 파악하고, 문제 발생 시 빠르게 감지하며, 반복적인 운영 작업을 자동화하여 효율성을 극대화해야 합니다.